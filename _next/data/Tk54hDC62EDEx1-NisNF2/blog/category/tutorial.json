{"pageProps":{"title":"Blog - tutorial | Karin Hendrikse","categories":["tutorial","javascript","nextjs","curated-color-schemes","beginner","accessibility","html","productivity","career","watercooler","remote","npm-and-yarn","hacktoberfest","open-source"],"posts":[{"layout":"post","title":"Authenticate third-party API's in Next.js using HttpOnly cookies and axios interceptors","published":true,"date":"2022-02-21","description":"How to store third-party API tokens using HttpOnly, including refreshing tokens using axios request interceptors.","cover_image":"2022-02-21.jpg","cover_image_alt":"a cat taking a very cozy nap","tags":"tutorial, javascript, nextjs","oldBlog":false,"markdownBody":"\n_It's the beginning of 2022, and before I dive into this tech filled post, I just wanted to start off cozy and calm. With this amazing picture by Aleksandar Cvetianovic. Take it in. Breathe... and let's go._\n\nPhoto by [Aleksandar Cvetanovic](https://unsplash.com/@lemonzandtea?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) on [Unsplash](https://unsplash.com/s/photos/cozy?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)\n\n## TL;DR\n\nIn this article, we're going to look into storing and managing refreshing authentication tokens from third-party API's using Next.js. We'll use [HttpOnly cookies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies) and deal with expiring tokens using [axios interceptors](https://axios-http.com/docs/interceptors). Scroll down to \"The setup\" for all the details.\n\n## Background\n\nLast year I was working on a personal project where I was using a third-party API. I researched ways in which I could store the user access token **without** having to create my own database. One of the possibilities was using HttpOnly cookies. I had already decided to go for Next.js because of the quick server setup that comes with it. I implemented the authentication flow and searched for the logic to refresh tokens. This is how I solved it:\n\n## The setup\n\n### Preface\n\nTo follow along, you need to already know how to do the following:\n\n- [set up a Next.js project](https://nextjs.org/docs/getting-started)\n- authenticate the third-party API you're going to use through [Next.js API routes](https://nextjs.org/docs/api-routes/introduction).\n- understand the logic to refresh your tokens for your third-party API.\n\n### Storing your refresh token inside a HttpOnly cookie\n\nTo securely store the third-party API refresh token, we'll use a HttpOnly cookie. To read more about the security they can provide, [check out the docs at MDN.](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies).\n\n> **To figure out yourself:**\n>\n> To start, make sure you have your Next.js project setup with a server that manages getting the refresh token from your third-party API. I'm assuming you've created your own endpoint in the `pages/api` folder. For this example, I'll call the file `getRefreshToken.js`.\n\nWe're going to use the [cookie](https://www.npmjs.com/package/cookie) library to help deal with setting our cookie. To add it to our project:\n\n```shell\n$ npm install cookie\n\n// or\n\n$ yarn add cookie\n\n```\n\nWe will create our cookie in the `getRefreshToken.js` file. After getting your refresh token, use the `res` parameter that is exposed from the request handler in the `get-token` endpoint.\n\n```js\n// pages/api/getRefreshToken.js\n\n// --- all the logic you wrote yourself to get the refresh_token\n\nres.setHeader('Set-Cookie', [\n  cookie.serialize('refreshToken', refresh_token, {\n    httpOnly: true,\n    secure: process.env.NODE_ENV !== 'development',\n    maxAge: 60 * 60 * 24,\n    sameSite: 'strict',\n    path: '/'\n  })\n]);\n```\n\nTo enable the cookie as HttpOnly, we set `httpOnly: true`. To only allow access through HTTPS protocol, add `secure: process.env.NODE_ENV !== 'development'`. Currently, HTTPS is usually not used on `localhost`, so we set it up to only use `secure: true` on production. If you're curious about this, you can [read up on it on MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies).\n\nSet `maxAge: 60 * 60 * 24`, to define the amount of seconds before the cookie expires. In this case it sets it to 24 hours. This will force the token to be invalidated after 24 hours.\n\nEventually the endpoint will look something like this:\n\n```js\n// pages/api/getRefreshToken.js\nimport axios from 'axios';\nimport cookie from 'cookie';\n\nconst getRefreshToken = async (req, res) => {\n  // we use this 'res' parameter to set the cookie.\n\n  // any logic you need to get your refresh token, including\n\n  const options = {\n    // all necessary options for getting the refresh token\n  };\n\n  const fetchData = () =>\n    axios(options)\n      .then(async response => {\n        const { refresh_token } = response.data;\n\n        res.setHeader('Set-Cookie', [\n          cookie.serialize('refreshToken', refresh_token, {\n            httpOnly: true,\n            secure: process.env.NODE_ENV !== 'development',\n            maxAge: 60 * 60 * 24,\n            sameSite: 'strict',\n            path: '/'\n          })\n        ]);\n\n        res.statusCode = 200;\n        res.setHeader('Content-Type', 'application/json');\n        res.end(JSON.stringify({ refresh_token }));\n      })\n      .catch(error => {\n        // logic for handling errors\n      });\n\n  await fetchData();\n};\n\nexport default getRefreshToken;\n```\n\nIf you ever want to use this cookie, you can find it on the `req` object on any call to your Next.js server. It will be available in `req.cookies`.\n\n### Encrypting our refresh token\n\nBecause a refresh token is an important part of the authentication flow, we'll add an extra layer of security by encrypting it. We will use the library [`crypto-js`](https://www.npmjs.com/package/crypto-js) for this. This library can help us encrypt our token using an 'encryption key' or password. This password will only be available to our server. This way the server is able to encrypt and decrypt the token.\n\n```shell\n$ npm install crypto-js\n\n// or\n\n$ yarn add crypto-js\n\n```\n\nIn our `env.local` file (which we do not commit!) we add an environment variable with a encryption key of approximately 32 characters. Make sure this key is truly secret, random and secure!\n\n```env\n// .env.local\nENCRYPT_KEY=theverylongpasswordwith32characters\n```\n\nIn the `getRefreshToken.js` file, import `AES` from `crypto-js/aes`. In the object where we set `refreshToken`, use the `encode` key in the cookie object to pass the function that will encrypt the token:\n\n```js\n// pages/api/getRefreshToken.js\n\nimport AES from 'crypto-js/aes';\n\n// ...\n\ncookie.serialize('refreshToken', refresh_token, {\n  httpOnly: true,\n  secure: process.env.NODE_ENV !== 'development',\n  maxAge: 60 * 60 * 24,\n  sameSite: 'strict',\n  path: '/',\n  encode: value => AES.encrypt(value, process.env.ENCRYPT_KEY).toString()\n});\n```\n\nWhenever you want to use this token you do need to decrypt it using the encryption key like so:\n\n```js\nimport CryptoJS from 'crypto-js';\n\n// In the place where you use your refresh token:\nconst { refreshToken } = req.cookies;\nconst decryptedRefresh = CryptoJS.AES.decrypt(\n  refreshToken,\n  process.env.ENCRYPT_KEY\n).toString(CryptoJS.enc.Utf8);\n```\n\n### Setting up an axios instance to manage refresh tokens\n\nWhenever a token expires or is incorrect, we'll try and refresh them. Usually, in the cases that this happens, an API would return [`401 Unauthorized`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/401).\n\nTo deal with this we're going to use [axios Interceptors](https://axios-http.com/docs/interceptors).\n\nYou can use an interceptor to 'intercept' requests or responses before they are actually handled. In this example we're going to:\n\n- Create our own axios instance and add a request and response interceptor to it.\n- Use this axios instance everywhere we are doing calls that use an access token.\n\nThis way, if an endpoint is using an access token to get data, and receives an `401 Unauthorized`, we can handle this by refreshing the token. Let's break this down:\n\nCreate your own axios instance inside a file called `axios-instance.js`:\n\n```js\n// axios-instance.js\nimport axios from 'axios';\n\nconst axiosInstance = axios.create();\n\nexport default axiosInstance;\n```\n\nTo add our interceptor logic we'll start with the response interceptor. Whenever we get a response from an API we check if it is `401 Unauthorized`. If that is the case we refresh the access token and try the call again. To do this we'll be using [axios-auth-refresh](https://www.npmjs.com/package/axios-auth-refresh) which makes it really easy to set this up.\n\nAdd the library:\n\n```js\nnpm install 'axios-auth-refresh'\n\n// or\n\nyarn add 'axios-auth-refresh'\n\n```\n\nInside the `axios-instance.js` file, import `createAuthRefreshInterceptor`. Then create a `refreshAuthLogic` function. This function has a failedRequest parameter that we receive from our interceptor.\n\n> **To figure out yourself:**\n>\n> Now it's up to you to create a function we can call that handles refreshing the access token from your third-party API. You can grab the refresh token from `req.cookies`. Don't forget to decrypt it like I showed you before! And make sure it returns the access token __without__ encryption.\n\nInside `refreshAuthLogic` we will use the refresh function you created yourself, in this example it's called `refreshAccessToken`. That function returns our new token, which we set as the response Authorization header. Finally, we return a resolved promise.\n\nWe then call the `createAuthRefreshInterceptor` function and pass in the `axiosInstance` and `refreshAuthLogic` function we created.\n\n```js\n// axios-instance.js\nimport axios from 'axios';\nimport createAuthRefreshInterceptor from 'axios-auth-refresh';\nimport refreshAccessToken from './refresh-access-token'; // this file contains any logic you need to refresh your token with your third-party API\n\nconst axiosInstance = axios.create();\n\nconst refreshAuthLogic = failedRequest =>\n  refreshAccessToken().then(tokenRefreshResponse => {\n    // get the new token\n    failedRequest.response.config.headers.Authorization = `Bearer ${tokenRefreshResponse.accessToken}`; // set the new token as the authorization header.\n    return Promise.resolve();\n  });\n\ncreateAuthRefreshInterceptor(axiosInstance, refreshAuthLogic);\n\nexport default axiosInstance;\n```\n\n> **To figure out yourself:**\n>\n> Something to keep in mind for the `refreshAccessToken` logic that you'll be creating yourself to get your refreshed token, is that you're going to have to make sure you also set this new refresh token as a cookie. You can use the same logic as we have used before for that.\n\nNow let's deal with the request interceptors. This is where the fun starts.\n\nInside our `axios-instance.js` file, we're going to create a `let requestToken;` empty variable. Then inside `refreshAuthLogic`, we assign the refreshed token to `requestToken`. This way, `requestToken` will always be up to date with the latest version of our token.\n\nAfter this we're going to set our own request interceptor. We tell it to check if `requestToken` is empty or not. If it is empty, we'll use the `refreshAccessToken` function to get a new token. If it is not empty, we use `requestToken` as our authorization header:\n\n```js\n// axios-instance.js\nimport axios from 'axios';\nimport createAuthRefreshInterceptor from 'axios-auth-refresh';\nimport refreshAccessToken from './refresh-access-token';\n\nlet requestToken;\n\nconst axiosInstance = axios.create();\n\nconst refreshAuthLogic = failedRequest =>\n  refreshAccessToken().then(tokenRefreshResponse => {\n    failedRequest.response.config.headers.Authorization = `Bearer ${tokenRefreshResponse.accessToken}`;\n    requestToken = tokenRefreshResponse.accessToken; // change the requestToken with the refreshed one\n    return Promise.resolve();\n  });\n\ncreateAuthRefreshInterceptor(axiosInstance, refreshAuthLogic);\n\naxiosInstance.interceptors.request.use(async request => {\n  if (!requestToken) {\n    refreshAccessToken().then(tokenRefreshResponse => {\n      requestToken = tokenRefreshResponse.accessToken;\n    });\n  }\n\n  request.headers.Authorization = `Bearer ${requestToken}`;\n  return request;\n});\n\nexport default axiosInstance;\n```\n\nFrom this point on, any request that is made using the axios instance, will grab the authorization token from the `let requestToken` in this file _before_ doing a request. So if an earlier request refreshed the token, the next one is able to use the refreshed one. And that's it!\n","slug":"nextjs-auth-with-httponly-cookies-incl-refresh"},{"layout":"post","title":"Coding with a group of 11 year olds","published":true,"oldBlog":true,"date":"2019-10-07","description":"Get them 'hacking' their favourite websites","tags":"beginner, tutorial","intro":"Recently a we were asked if we could give a short lesson about coding to a group of 11 year olds in primary school. So my colleague and me started preparing a 1,5 hour workshop with the goal of showing the kids how much fun programming could be. This is the story of how it went.","cover_image":"https://media.giphy.com/media/l41lZlI5EjpMCaVdC/giphy.gif","cover_image_alt":"a cute moving image with a keyboard and cartoon cats going up and down","markdownBody":"\n## Get to know what they love\nOur goal was to stay as close to their own interests as possible. So with a little bit of research we discovered that these kids really loved to use mobile phones and consoles outside of school. Generally most of them knew and used apps like TikTok, SnapChat and WhatsApp, they regularly visited YouTube for watching videos and some of the kids played Minecraft or Fortnite at home.\n\n## Make it interactive\nTo keep them engaged we used [Kahoot](https://kahoot.com/). We wanted to switch between our (giphy-filled) slides and the Kahoot to ask them a few questions now and then about what we were talking about. When we actually had the lesson we decided to first just do all of the questions with Kahoot, talk a little about the answers and then dive deeper into them after the quiz. The kids really liked the quiz and already knew how it worked.\n\n*Tip:* make them understand that it is okay if they didn't get the answer. We also need to google most of what we do when we code.\n\n## Explain programming\nAs we only had 1,5 hours, we talked about a few basic things:\n\n* We dived into how a lot of things in our daily lives have a 'computer' inside of them. Washing machines, phones, laptops, tablets, consoles, even cars and satellites. And how cool it is that this means you can also program stuff for those devices.\n* We discussed how a computer knows what to do. For this we used the ['tell this person what to do'](#the-person-is-a-computer-exercise) exercise.\n* We explained how developers write computer programs, and that there are [different types of developers](#different-types-of-developers). We also talked about diversity in tech when it comes to people and their backgrounds, but also about the different types of developers.\n\n## The person is a computer exercise\nInspired by [@FloorDrees](https://twitter.com/FloorDrees) who did this exercise during a [RailsGirls](http://www.railsgirls.com) event. We let the kids steer me into writing a word on a whiteboard. The kids were pretty good at understanding that they had to be pretty specific in telling me what to do. 'Step forward', 'put your right hand forward' 'clench your hand around the object that is now referred to as a marker' etc. Some were even quick enough to understand that I had to remove the cap before writing.\n\n## Different types of developers\nThis is where our deep dive of their hobbies and interaction with the internet came in handy. We got to show them that there are different types of developers.\n* Some like to write software that helps get a rocket from the earth to mars.\n* Some want to make apps for phones and tablets, like TikTok, WhatsApp and SnapChat.\n* Some want to build websites, like the website of their favourite hiphop artists or YouTube.\n* Some want to make games, like Minecraft and Fortnite.\n\n\n## We let them 'hack' a website\nAfter the quiz and our explaining of what you can do with programming. We let them do a short 'hacking' exercise. On their laptops they got to go to their favourite website. Which, for most was YouTube or a popular news website as that is where we showed an example. Then by using `inspect` in the browser, we let them change the text of a video title or news article. This mostly resulted in videos of famous soccer players having titles with the kids names in them. They got to take screenshots which they got to share with their families later.\n\n## Wrapping it up\nFor the last few minutes one of us sat in front of the class to change colours and fonts on websites. After this we talked about how their changes will be lost once they refresh the page. And that it is a good thing that not anyone can just change news titles because then people could change other peoples work, or change the news however they would want. I think we were both very impressed on how aware the kids were of the danger of spreading lies and 'fake news'.\n\nThe kids also got to ask us a few more questions about what it is like to be a developer and how you can become one. Before we knew it, the lesson was over and the kids continued with their normal school day.\n\nWe had a huge amount of fun, but were exhausted 😂🥳. It was an amazing experience and if you ever get asked to do something similar, I would really consider going for it. It was very rewarding and simply loads of fun. Have you ever done something similar? Please let me know in the comments!\n\n","slug":"coding-with-a-group-of-11-year-olds"}],"currentCategory":"tutorial"},"__N_SSG":true}