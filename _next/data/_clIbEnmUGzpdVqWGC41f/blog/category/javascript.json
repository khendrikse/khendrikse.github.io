{"pageProps":{"title":"Blog - javascript | Karin Hendrikse","categories":["tutorial","javascript","nextjs","curated-color-schemes","beginner","accessibility","html","productivity","career","watercooler","remote","npm-and-yarn","hacktoberfest","open-source"],"posts":[{"layout":"post","title":"Authenticate third-party API's in Next.js using HttpOnly cookies and axios interceptors","published":true,"date":"2022-02-21","description":"How to store third-party API tokens using HttpOnly, including refreshing tokens using axios request interceptors.","cover_image":"2022-02-21.jpg","cover_image_alt":"a cat taking a very cozy nap","tags":"tutorial, javascript, nextjs","oldBlog":false,"markdownBody":"\n_It's the beginning of 2022, and before I dive into this tech filled post, I just wanted to start off cozy and calm. With this amazing picture by Aleksandar Cvetianovic. Take it in. Breathe... and let's go._\n\nPhoto by [Aleksandar Cvetanovic](https://unsplash.com/@lemonzandtea?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) on [Unsplash](https://unsplash.com/s/photos/cozy?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)\n\n## TL;DR\n\nIn this article, we're going to look into storing and managing refreshing authentication tokens from third-party API's using Next.js. We'll use [HttpOnly cookies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies) and deal with expiring tokens using [axios interceptors](https://axios-http.com/docs/interceptors). Scroll down to \"The setup\" for all the details.\n\n## Background\n\nLast year I was working on a personal project where I was using a third-party API. I researched ways in which I could store the user access token **without** having to create my own database. One of the possibilities was using HttpOnly cookies. I had already decided to go for Next.js because of the quick server setup that comes with it. I implemented the authentication flow and searched for the logic to refresh tokens. This is how I solved it:\n\n## The setup\n\n### Preface\n\nTo follow along, you need to already know how to do the following:\n\n* [set up a Next.js project](https://nextjs.org/docs/getting-started)\n* authenticate the third-party API you're going to use through [Next.js API routes](https://nextjs.org/docs/api-routes/introduction).\n* understand the logic to refresh your tokens for your third-party API.\n\n### Storing your tokens inside HttpOnly cookies\n\nTo securely store the third-party API tokens, we'll use HttpOnly cookies. To read more about the security they can provide, [check out the docs at MDN.](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies).\n\n> **To figure out yourself:**\n>\n>To start, make sure you have your Next.js project setup with a server that manages getting the tokens from your third-party API. I'm assuming you've created your own endpoint in the `pages/api` folder. For this example, I'll call the file `getToken.js`.\n\nWe're going to use the [cookie](https://www.npmjs.com/package/cookie) library to help deal with setting our cookies. To add it to our project:\n\n```shell\n$ npm install cookie\n\n// or\n\n$ yarn add cookie\n\n```\n\nWe will create our cookies in the `getToken.js` file. After getting your tokens, use the `res` parameter that is exposed from the request handler in the `get-token` endpoint.\n\n```js\n// pages/api/getToken.js\n\n// --- all the logic you wrote yourself to get the access_token\n\nres.setHeader('Set-Cookie', [\n  cookie.serialize('accessToken', access_token, {\n    httpOnly: true,\n    secure: process.env.NODE_ENV !== 'development',\n    maxAge: 60 * 60 * 24,\n    sameSite: 'strict',\n    path: '/'\n  })\n  cookie.serialize('refreshToken', refresh_token, {\n    httpOnly: true,\n    secure: process.env.NODE_ENV !== 'development',\n    maxAge: 60 * 60 * 24,\n    sameSite: 'strict',\n    path: '/'\n  })\n]);\n```\n\nTo enable these cookies as HttpOnly, we set `httpOnly: true`. To only allow access through HTTPS protocol, add `secure: process.env.NODE_ENV !== 'development'`. Currently, HTTPS is usually not used on `localhost`, so  we set it up to only use `secure: true` on production. If you're curious about this, you can [read up on it on MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies).\n\nSet `maxAge: 60 * 60 * 24`, to define the amount of seconds before the cookie expires. In this case it sets it to 24 hours. This will force the token to be invalidated after 24 hours.\n\nAdd this logic for all the cookies you want to set. Eventually the endpoint will look something like this:\n\n```js\n// pages/api/getToken.js\nimport axios from 'axios';\nimport cookie from 'cookie';\n\nconst getToken = async (req, res) => { // we use this 'res' parameter to set the cookies.\n\n  // any logic you need to get your tokens, including\n\n  const options = {\n    // all necessary options for getting the right tokens\n  };\n\n  const fetchData = () =>\n    axios(options)\n      .then(async response => {\n        const { access_token, refresh_token } = response.data;\n\n        res.setHeader('Set-Cookie', [\n          cookie.serialize('accessToken', access_token, {\n            httpOnly: true,\n            secure: process.env.NODE_ENV !== 'development',\n            maxAge: 60 * 60 * 24,\n            sameSite: 'strict',\n            path: '/'\n          }),\n          cookie.serialize('refreshToken', refresh_token, {\n            httpOnly: true,\n            secure: process.env.NODE_ENV !== 'development',\n            maxAge: 60 * 60 * 24,\n            sameSite: 'strict',\n            path: '/'\n          })\n        ]);\n\n        res.statusCode = 200;\n        res.setHeader('Content-Type', 'application/json');\n        res.end(JSON.stringify({ access_token, refresh_token }));\n      })\n      .catch(error => {\n        // logic for handling errors\n      });\n\n  await fetchData();\n};\n\nexport default getToken;\n```\n\nIf you want to ever use these cookies, you can find them on the `req` object on any call to your Next.js server. They will be available in `req.cookies`.\n\n### Encrypting our refresh token\n\nBecause a refresh token is an important part of the authentication flow, we'll add an extra layer of security by encrypting it. We will use the library [`crypto-js`](https://www.npmjs.com/package/crypto-js) for this. This library can help us encrypt our token using an 'encryption key' or password. This password will only be available to our server. This way the server is able to encrypt and decrypt the token.\n\n```shell\n$ npm install crypto-js\n\n// or\n\n$ yarn add crypto-js\n\n```\n\nIn our `env.local` file (which we do not commit!) we add an environment variable with a encryption key of approximately 32 characters. Make sure this key is truly random.\n\n```env\n// .env.local\nENCRYPT_KEY=theverylongpasswordwith32characters\n```\n\nIn the `getToken.js` file, import `AES` from `crypto-js/aes`. In the object where we set `refreshToken`, use the `encode` key in the cookie object to pass the function that will encrypt the token:\n\n```js\n// pages/api/getToken.js\n\nimport AES from 'crypto-js/aes';\n\n// ...\n\ncookie.serialize('refreshToken', refresh_token, {\n  httpOnly: true,\n  secure: process.env.NODE_ENV !== 'development',\n  maxAge: 60 * 60 * 24,\n  sameSite: 'strict',\n  path: '/',\n  encode: value => AES.encrypt(value, process.env.ENCRYPT_KEY).toString()\n});\n```\n\nWhenever you want to use this token you do need to decrypt it using the encryption key like so:\n\n```js\nimport CryptoJS from 'crypto-js';\n\n// In the place where you use your refresh token:\nconst { refreshToken } = req.cookies;\nconst decryptedRefresh = CryptoJS.AES.decrypt(\n  refreshToken,\n  process.env.ENCRYPT_KEY\n).toString(CryptoJS.enc.Utf8);\n```\n\n### Setting up an axios instance to manage refresh tokens\n\nWhenever a token expires or is incorrect, we'll try and refresh them. Usually, in the cases that this happens, an API would return [`401 Unauthorized`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/401).\n\nTo deal with this we're going to use [axios Interceptors](https://axios-http.com/docs/interceptors).\n\nYou can use an interceptor to 'intercept' requests or responses before they are actually handled. In this example we're going to:\n\n- Create an endpoint that grabs the token from our cookies.\n- Create our own axios instance and add a request and response interceptor to it.\n- Use this axios instance everywhere we are doing calls that use a token.\n\nThis way, if an endpoint is using a token to get data, and receives an `401 Unauthorized`, we can handle this by refreshing our token. Let's break this down:\n\nCreate an endpoint inside the `api` folder to grab the token from our cookie.\n\n```js\n// api/getToken.js\n\nconst getToken = async (req, res) => {\n  const { accessToken } = req.cookies; // we are able to get our cookies from our request object.\n\n  res.statusCode = 200;\n  res.setHeader('Content-Type', 'application/json');\n  res.end(JSON.stringify({ accessToken }));\n};\n\nexport default getToken;\n```\n\nThen we create our own axios instance inside a file called `axios-instance.js`:\n\n```js\n// axios-instance.js\nimport axios from 'axios';\n\nconst axiosInstance = axios.create();\n\nexport default axiosInstance;\n```\n\nTo add our interceptor logic we'll start with the response interceptor. Whenever we get a response from an API we check if it is `401 Unauthorized`. If that is the case we refresh the token and try the call again. To do this we'll be using [axios-auth-refresh](https://www.npmjs.com/package/axios-auth-refresh) which makes it really easy to set this up.\n\nAdd the library:\n\n```js\nnpm install 'axios-auth-refresh'\n\n// or\n\nyarn add 'axios-auth-refresh'\n\n```\n\nInside the `axios-instance.js` file, import `createAuthRefreshInterceptor`. Then create a `refreshAuthLogic` function. This function has a failedRequest parameter that we receive from our interceptor.\n\n>**To figure out yourself:**\n>\n>Now it's up to you to create a function we can call that handles refreshing the access token from your third-party API. You can grab the refresh token from `req.cookies`. Don't forget to decrypt it like I showed you before!\n\nInside `refreshAuthLogic` we will use the refresh function you created yourself, in this example it's called `refreshAccessToken`. That function returns our new token, which we set as the response Authorization header. Finally, we return a resolved promise.\n\nWe then call the `createAuthRefreshInterceptor` function and pass in the `axiosInstance` and `refreshAuthLogic` function we created.\n\n```js\n// axios-instance.js\nimport axios from 'axios';\nimport createAuthRefreshInterceptor from 'axios-auth-refresh';\nimport refreshAccessToken from './refresh-access-token'; // this file contains any logic you need to refresh your token with your third-party API\n\nconst axiosInstance = axios.create();\n\nconst refreshAuthLogic = failedRequest =>\n  refreshAccessToken().then(tokenRefreshResponse => {\n    // get the new token\n    failedRequest.response.config.headers.Authorization = `Bearer ${tokenRefreshResponse.accessToken}`; // set the new token as the authorization header.\n    return Promise.resolve();\n  });\n\ncreateAuthRefreshInterceptor(axiosInstance, refreshAuthLogic);\n\nexport default axiosInstance;\n```\n\n>**To figure out yourself:**\n>\n>Something to keep in mind for the `refreshAccessToken` logic that you'll be creating yourself to get your refreshed token, is that you're going to have to make sure you also set these new tokens as cookies. You can use the same logic as we have used before for that.\n\nThis solution works if you are doing just one call at a time. It will refresh the token, set the token in our cookies and try the call again. After that, if you do a brand new call, it will use the updated token from the cookie.\n\nBut if you are doing multiple calls at the same time, we run into a problem.\n\n**Example**\n\nLet's say I'm using the [Spotify API](https://developer.spotify.com/documentation/web-api/) and I've got a list of 10 artist. For each artists I want to do a call to get more information on them:\n\n```js\nPromise.all(tenArtists.map(artist => doCall(artist)));\n```\n\nEach call will start off with the old token, and will try to use it when doing its call. It will get a response with `401 Unauthorized` and refresh the token, set the new cookie and try again. This will happen again and again 10 times. This is because all of these calls started off with the old token, which does not get updated after the first call has refreshed it. So let's fix this.\n\nInside our `axios-instance.js` file, we're going to create a `let requestToken;` empty variable. Then inside `refreshAuthLogic`, we assign the refreshed token to `requestToken`. This way, `requestToken` will always be up to date with the latest version of our token.\n\nAfter this we're going to set our own request interceptor. we tell it to check if `requestToken` is empty or not. If it is empty, we'll use the endpoint we made in the beginning to get the token from our cookies. If it is not empty, we use that token as our authorization header:\n\n```js\n// axios-instance.js\nimport axios from 'axios';\nimport createAuthRefreshInterceptor from 'axios-auth-refresh';\nimport refreshAccessToken from './refresh-access-token';\n\nlet requestToken;\n\nconst axiosInstance = axios.create();\n\nconst refreshAuthLogic = failedRequest =>\n  refreshAccessToken().then(tokenRefreshResponse => {\n    failedRequest.response.config.headers.Authorization = `Bearer ${tokenRefreshResponse.accessToken}`;\n    requestToken = tokenRefreshResponse.accessToken; // change the requestToken with the refreshed one\n    return Promise.resolve();\n  });\n\ncreateAuthRefreshInterceptor(axiosInstance, refreshAuthLogic);\n\naxiosInstance.interceptors.request.use(async request => {\n  if (!requestToken) {\n    const { accessToken } = await axios\n      .get('/api/getToken')\n      .then(({ data }) => data)\n      .catch(error => Promise.reject(error.response.data));\n\n    requestToken = accessToken;\n  }\n\n  request.headers.Authorization = `Bearer ${requestToken}`;\n  return request;\n});\n\nexport default axiosInstance;\n```\n\nFrom this point on, any request that is made using the axios instance, will grab the authorization token from the `let requestToken` in this file _before_ doing a request. So if an earlier request refreshed the token, the next one is able to use the refreshed one.\n\nAnd that's it! This solution hardly feels perfect for me. But for an app that has a lot of client-side calls, without a real database and trying to use HttpOnly cookies, this was one of the solutions I was able to come up with.\n","slug":"nextjs-auth-with-httponly-cookies-incl-refresh"},{"layout":"post","title":"Test global npm packages in a quick and easy way","published":true,"oldBlog":true,"date":"2020-06-16","description":"A quick guide on testing out local global npm packages line using npm or yarn.","intro":"You might already be used to creating symlinks between projects locally using yarn or npm. But what if you are  working on a cli package that you want the user to use globally? You also want to be able to test your package locally to make sure everything is working as it should. But how do you do this? Here‚Äôs an easy guide on achieving a link to a local project to test out globally in your command line using either yarn or npm.","tags":"beginner, javascript, npm-and-yarn","cover_image":"2020-06-16.png","cover_image_alt":"illustration of chains","markdownBody":"\n## How do you link projects?\n\nLet‚Äôs say you are working on a React app and you have another project, like a component library, that you are also working on at the same time. You want to make changes in your component library and test them out in your React app without first having to deploy the entire package right? Let‚Äôs talk about how you can actually do this. Please don‚Äôt forget: the React app and component library are examples. You can do this with any project.\n\n### 1. Making your package available\n\nFirst we need to make the package (in our example a component library) available in your local system by going into its folder using your terminal and running:\n\n```shell\n# yarn\nyarn link\n\n# npm\nnpm link\n```\n\n\n**What does this do?**\n\nThis command creates a symlink to our package in a specific location. You can see them in the location by going to the location:\n\n```shell\n# yarn\ncd ~/.config/yarn/link\n\n# npm\n# first figure out where your npm packages are saved by running\n\nnpm config ls -l\n\n# find the ‚Äòprefix‚Äô key\n# you can find where your packages are saved in\n\ncd {prefix}/lib/node_modules\n```\n\nThen run `ls` to see a list of all the packages that are installed.\n\n\n> **You keep talking about symlinks. What are those?**\n> A symlink (or ‚Äòsymbolic link‚Äô) is a file that has a reference to another file. You can also explain it as being a file that points to another file, or you can see it as a ‚Äòshortcut‚Äô on your computer.\n>\n>When you create a symlink you are telling your computer to create a link to file A. This link is saved in file B. When we want to use file B, we are essentially using file A.\n\n### 2. Linking to your package\n\nWe now go to the project where you want to use the package (in our example the React app). In here we run\n\n```shell\n# yarn\nyarn link <package name>\n\n# So, let‚Äôs say that your package‚Äôs name is ‚Äòcatpaws‚Äô you will do\nyarn link ‚Äúcatpaws‚Äù\n\n# npm\nnpm link <package name>\n\n# So, let‚Äôs say that your package‚Äôs name is ‚Äòcatpaws‚Äô you will do\nnpm link ‚Äúcatpaws‚Äù\n```\n\nAwesome.\n\nYour project now has its package linked locally so you can test everything out. Are you done testing? Then make sure to unlink the package in your project folder by running:\n\n```shell\n# yarn\nyarn unlink <package name>\n\n# npm\nnpm unlink <package name>\n```\n\nAnd remove the package from the symlinks list by going to the folder of your package and running:\n\n```shell\n# yarn\nyarn unlink\n\n# npm\nnpm unlink\n```\n\n\n## How to link to your package globally?\n\nSo it‚Äôs all great to know how to create local links between projects, but how about when you don‚Äôt have a project, but your computer that needs to globally link to your local package? Well, it‚Äôs actually a bit different, but still super easy. First, let‚Äôs check which packages you already have installed globally by running:\n\n```shell\n# yarn\nyarn global list\n\n# yarn\nnpm ls -g --depth=0 --link=true\n```\n\nYou should get a nice overview of stuff that is already installed.\n\n### 1. Link to your package.\n\n**yarn**\nIn your terminal, run `yarn global add /full/path/to/package`.\nIf we now run `yarn global list` again, we should see the name of our package in the list.\n\nIf you want to remove it you simply run `yarn global remove ‚Äúpackage name‚Äù`.\n\nNow there is a tricky part here. Yarn does not fully seem to support globally linking to local packages yet so the way we do this is actually a bit hacky. You see, yarn does not automatically update the package you have added, so for each change you want to test, you have to add it again...\n\nIt's easier with npm:\n\n**npm**\nWith npm it it the same as before, but we just go to the folder of our package and run `npm link`.\n\nIf you now run `npm ls -g --depth=0 --link=true` you‚Äôll see that your package is in the list.\n\nYou remove it from the list by going into the package folder and running `npm unlink`.\n\n## Conclusion\nUsing either yarn or npm, once you know how, it can be easy to create symlinks to test any package between projects, or in global mode. Right now, npm seems to have the easiest workflow.\n\nI got stuck the first time I had to develop something that I wanted to test globally and it took me some time to figure out how to make this work. I hope this helps others who might encounter the same problem. If you have any other way to do this please share them in the comments so we can all learn from it üëç.\n","slug":"Test-global-npm-packages-in-a-quick-and-easy-way"},{"layout":"post","title":"The basics of a function, illustrated! ‚ú®","published":true,"oldBlog":true,"date":"2020-05-21","description":"Learn about JavaScript functions with a simple metaphor.","intro":"One thing that can be difficult to understand when you just start out learning how to program is what a function is and how it works. As a beginner developer, it can be especially difficult to understand what arguments are and where they come from. This blog illustrates how a  javascript function works in its most basic form.","tags":"beginner, javascript","cover_image":"https://dev-to-uploads.s3.amazonaws.com/i/tri97q55qgtexhhakgxe.png","cover_image_alt":"illustration of an abstract factory","markdownBody":"\n## What is a function\n\n*Functions are like small programs that are built to do a specific task.* We first create (or 'declare') this program (which we will from now on call a function). Once we are done writing it, we can start using (or 'execute') it.\n\nIt‚Äôs kind of like building a small factory. While setting up the factory we create a building. Inside this building, we set everything in place so the factory can receive whatever raw materials it needs and return whatever product we want as output.\n\nLet‚Äôs say we want to build a factory that takes any number and adds two. From the inside the factory would look something like this:\n\n![a factory that takes in a number and returns that number plus two](https://dev-to-uploads.s3.amazonaws.com/i/9onjc8zt7vpuommno32w.png)\n\nWe can see that the factory is expecting to get any type of number as input. Because we don‚Äôt know yet which number it might receive, we‚Äôll just call whatever input we get `num` for ‚Äònumber‚Äô. Inside the factory, we add 2 to whatever we got as input. It then returns the output which is the combination of `num + 2`.\n\n>### About `num`\n>`num` is just a representation, or container, for what we get as input. We can even rename it into whatever we want. If we were making a factory that added two apples to a number of bananas, we could rename `num` to `bananas`. The input would be a number of bananas, the output would be a number of bananas plus two apples.\n\nDo you see that we also gave the factory a name? `plusTwo`. This makes it a bit easier for when we want to refer to the factory. This way we can tell our workers: ‚ÄòI want you to use the factory `plusTwo` to process a specific number and add 2‚Äô.\n\nOur factory is ready to be used now. To use it we need to provide a number as input. Let‚Äôs say we want to give it a `3` as input. We can‚Äôt see what is happening inside the factory but we can see what is returned from the factory: it‚Äôs a 5 (3 + 2 = 5):\n\n![The outside of a factory that takes in 3 and returns 5](https://dev-to-uploads.s3.amazonaws.com/i/o65pxtvzpgwjbkccobaa.png)\n\n## Let‚Äôs get coding\n\nFunctions essentially work the same way. Instead of building an imaginary factory, let‚Äôs actually start creating a function in JavaScript.\n\nWe first set up the function, these are like the walls of the factory. For convenience, we will also give the function a name, just like we did with the factory. We‚Äôll call it `plusTwo`.\n\n```js\n\nfunction plusTwo( ) {\n\n}\n\n```\n\nWe are then going to define what we are expecting the program to get as input. We call these `arguments` or `parameters`. In this case, we are expecting to get one number. And because it can be any type of number, we‚Äôre going to give it a more generic name like `num`. We will define this argument within the two parentheses `()`. Look at it as the door that allows our input arguments to enter the function.\n\n```js\n\nfunction plusTwo(num) {\n\n}\n\n```\n\nWe‚Äôll now finish the function by saying exactly what it needs to do and return. It needs to return the sum of `num` and 2. This will become the output of the function.\n\n```js\n\nfunction plusTwo(num) {\n    return num + 2;\n}\n\n```\n\nNow the function is ready to be used. It knows what it is going to get as input, and what it needs to return as output. The part where we use the word `return` is actually really important. This tells the function to `return` our output.\n\nOtherwise, it is kind of like closing the output door to our factory: the produced results cannot leave the factory:\n\n![The factory output door is closed and none of the product can get out](https://dev-to-uploads.s3.amazonaws.com/i/b77bysgp94758d7vx8ul.png)\n\n>### Again, what is `num`?\n>We can rename `num` into whatever we like. It is just a name that we make up to define whatever enters our function. For example, the following two functions would have the exact same result:\n\n```js\nfunction plusTwo(x) {\n    return x + 2;\n}\n\nfunction plusTwoApples(numberOfApples) {\n    return numberOfApples + 2;\n}\n```\n\n>`x` and `numberOfApples` are simply names we give whatever arguments we are going to get. While we could use `x` as a name for our arguments, it does not tell us a lot about what we are getting. This is why we try to give it a more descriptive name.\n\nFrom now on, if you want to code along, you can actually [open developer tools](https://developers.google.com/web/tools/chrome-devtools/open) on this page and first type the function that we made just now, press return on your keyboard, and follow along for the next part.\n\n## Start using the function\n\nWe can now actually start using the function. Remember that we gave both the factory and the function a name? Just like with the factory, we can now tell our workers (in this case, our program) to use the function `plusTwo` to process a number and add 2‚Äô.\n\n```js\n\nplusTwo(3) // returns 5\n\n```\n\nWe pass the number 3 into the doors that are our parentheses. In the function, this means that `num` now is a representation of 3. In our factory drawings you imagine `num` to be 3.\n\nIf we pass 5, it will return 7:\n\n```js\n\nplusTwo(5) // returns 7\n\n```\n\nAgain, in our function `num` now is a representation of 5. In our factory drawings you imagine `num` to be 5.\n\nAnd that‚Äôs it! There is a lot more to learn about functions, but these are the basics that should help you get on your way! I hope it helps anyone learning this for the first time to understand the concepts a bit more.\n\n\n\n","slug":"The-basics-of-a-function-illustrated"}],"currentCategory":"javascript"},"__N_SSG":true}